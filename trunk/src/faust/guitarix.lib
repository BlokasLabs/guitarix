/****************************************************************
** helper definitions
*/
bypass(switch, block) = _ <: select2(switch, _, block);
BP(block) = bypass(checkbox("ON"), block);

copysign = ffunction(float copysign(float,float), <math.h>, "");

anti_denormal = pow(10,-20);
//add_dc = +(anti_denormal);
add_dc = +(0);
anti_denormal_ac = 1 - 1' : *(anti_denormal) : + ~ *(-1);

smoothi(c) = *(1-c) : +~*(c);

clip(lo,hi) = min(hi) : max(lo);
sym_clip(thr) = clip(-thr,thr);

balance(b) = *(1 - max(0, b)), *(1 - max(0, -b));
wet_dry_mix(w, Fx) = _ <: _, Fx : balance(w) : +;


/****************************************************************
** nonlinear functions
*/

// from thesis of Ragnar Bendiksen (used in swh ladspa valve plugin)

valve = environment {
    ex(x) = (1 - exp(-x));
    nlim = 50; // exp(-nlim)+1 == 1, exp(nlim)/(exp(nlim)+1) == 1

    tr(x) = select2(abs(x) > eps, tr_taylor(x), tr_func(max(-600,x))) with
    {
        eps = pow(10,-4);
        tr_func(x) = select2(x < -nlim, x / ex(x), -x*exp(x));
        tr_taylor(x) = 1 + x/2 + x*x/12;
    };
    df(x) = select2(abs(x) > eps, df_taylor(x), df_func(max(-600,x))) with
    {
        eps = pow(10,-4);
        df_func(x) = select2(x < -nlim, 1/ex(x) - (x * exp(-x)) / (ex(x)*ex(x)), -x*exp(x));
        df_taylor(x) = 0.5 + x/6 - x*x*x/180;
    };
    qd(dist, q, x) = dist * (x - q);
    vt(dist, q, x) = (tr(qd(dist, q, x)) - tr(qd(dist, q, 0))) / dist;
    vt_scaled(dist, q, x) = select2(dist*q > nlim, vt(dist, q, x) / df(qd(dist, q, 0)), vt_lim(dist, q, x)) with
    {
        bigval = pow(10,10);
        f(dist, q, x) = (qd(dist, q, x)/(1 - exp(-qd(dist, q, x)))*exp(dist*q) - dist*q)/(dist*dist*q);
        vt_lim(dist, q, x) = select2(dist*x > nlim, select2(dist*x < -nlim, f(dist, q, x), -1/dist), bigval);
    };
    vts(dist, q, x) = abs(x) : neg : vt_scaled(dist, q) : copysign(_, x);
    vtu(dist, q, g) = vt_scaled(dist, q) : *(g) : neg : vt(dist, q) : neg;
    vtu_(dist, q, g) = vt_scaled(dist, q) :neg :  *(g) : vt_scaled(dist, q) : /(g) : neg;
};

saturate(t, x) = select2(abs(x) < t, x, v)
with {
  sigmoid(x) = x * (1.5 - 0.5 * x * x);
  sat(x) = t + (1 - t)*sigmoid((abs(x)-t)/((1-t)*1.5));
  v = copysign(x, sat(x));
};

nonlin(a,b,c,x) = ((a * x - b * abs(x) * x) - x) * c;
nonlin1 = nonlin(2,1,0.5);


/****************************************************************
** filter
*/

//---------------------second order Parametric Equalizer---------
// filter(Q,F,G)
//  			Q : quality factor [1..100]
//				F :	frequency (Hz)
//				G : gain [0..1]
//---------------------------------------------------------------
// from "bandfilter.dsp" in the faust2pd distribution 
// which was released under the BSD license.

eqfilter(Q,F,G)	= TF2(  (1 +  K/Q + K*K) 	/ D,
						 2 * (K*K - 1) 		/ D,
						(1 - K/Q + K*K) 	/ D,
						 2 * (K*K - 1) 		/ D,
						(1 - V*K/Q + K*K) 	/ D
					 )
		with {
				V = db2linear(G);
				K = tan(PI*F/SR);
				D = 1 + V*K/Q + K*K;
		};


ifilter(Q,F,G) = eqfilter(Q,F,-G);


/****************************************************************
** building blocks
*/
fuzzy_tube(a,b,c,fuzzy) = _ <: _ + nonlin(a,b,c) * fuzzy * 0.5 : sym_clip(0.7);

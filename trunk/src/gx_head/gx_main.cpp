/*
 * Copyright (C) 2009, 2010 Hermann Meyer, James Warden, Andreas Degert
 * Copyright (C) 2011 Pete Shorthose
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 * ---------------------------------------------------------------------------
 * ----------------------------------------------------------------------------
 *
 *    This is gx_head main.
 *
 * ----------------------------------------------------------------------------
 */

#include "guitarix.h"       // NOLINT

#include <giomm/init.h>     // NOLINT
#include <gtkmm/main.h>     // NOLINT
#include <gxwmm/init.h>     // NOLINT
#include <string>           // NOLINT


/****************************************************************
 ** class PosixSignals
 **
 ** Block unix signals and catch them in a special thread.
 ** Blocking is inherited by all threads created after an
 ** instance of PosixSignals
 */

class PosixSignals {
private:
    sigset_t waitset;
    Glib::Thread *thread;
    volatile bool exit;
    void signal_helper_thread();
    void quit_slot();
    void gx_ladi_handler();
    void create_thread();
public:
    PosixSignals();
    ~PosixSignals();
};


PosixSignals::PosixSignals()
    : waitset(),
      thread(),
      exit(false) {
    sigemptyset(&waitset);
    /* ----- block signal USR1 ---------
    ** inherited by all threads which are created later
    ** signals are processed synchronously by signal_helper_thread
    */
    sigaddset(&waitset, SIGUSR1);
    sigaddset(&waitset, SIGCHLD);
    sigaddset(&waitset, SIGINT);
    sigaddset(&waitset, SIGQUIT);
    sigaddset(&waitset, SIGTERM);
    sigaddset(&waitset, SIGHUP);
    sigaddset(&waitset, SIGKILL);

    // ----- leave alone these signals: generated by programming errors
    // SIGABRT
    // SIGSEGV

    sigprocmask(SIG_BLOCK, &waitset, NULL);
    create_thread();
}

PosixSignals::~PosixSignals() {
    if (thread) {
	exit = true;
	kill(getpid(), SIGINT);
	thread->join();
    }
    sigprocmask(SIG_UNBLOCK, &waitset, NULL);
}

void PosixSignals::create_thread() {
    try {
	thread = Glib::Thread::create(
	    sigc::mem_fun(*this, &PosixSignals::signal_helper_thread), true);
    } catch (Glib::ThreadError& e) {
	throw gx_system::GxFatalError(
	    boost::format(_("Thread create failed (signal): %1%")) % e.what());
    }
}

void PosixSignals::quit_slot() {
    gx_system::GxExit::get_instance().exit_program();
}

void PosixSignals::gx_ladi_handler() {
    gx_system::gx_print_warning(
	_("signal_handler"), _("signal USR1 received, save settings"));
    gx_gui::GxMainInterface::get_instance().gx_settings.save_to_state();
}


// --- wait for USR1 signal to arrive and invoke ladi handler via mainloop
void PosixSignals::signal_helper_thread() {
    const char *signame;
    guint source_id_usr1 = 0;
    pthread_sigmask(SIG_BLOCK, &waitset, NULL);
    while (true) {
	int sig;
        int ret = sigwait(&waitset, &sig);
	if (exit) {
	    break;
	}
        if (ret != 0) {
            assert(errno == EINTR);
	    continue;
	}
	switch (sig) {
	case SIGUSR1:
	    if (Gtk::Main::level() < 1) {
		gx_system::gx_print_info(_("system startup"),
					 _("signal usr1 skipped"));
		break;
	    }
	    // do not add a new call if another one is already pending
	    if (source_id_usr1 == 0 ||
		g_main_context_find_source_by_id(NULL, source_id_usr1) == NULL) {
		const Glib::RefPtr<Glib::IdleSource> idle_source = Glib::IdleSource::create();
		idle_source->connect(
		    sigc::bind_return<bool>(
			sigc::mem_fun(*this, &PosixSignals::gx_ladi_handler),false));
		idle_source->attach();
		source_id_usr1 = idle_source->get_id();
	    }
	    break;
	case SIGCHLD:
	    Glib::signal_idle().connect_once(
		sigc::ptr_fun(gx_child_process::gx_sigchld_handler));
	    break;
	case SIGINT:
	case SIGQUIT:
	case SIGTERM:
	case SIGHUP:
	    switch (sig) {
	    case SIGINT:
		signame = _("ctrl-c");
		break;
	    case SIGQUIT:
		signame = "SIGQUIT";
		break;
	    case SIGTERM:
		signame = "SIGTERM";
		break;
	    case SIGHUP:
		signame = "SIGHUP";
		break;
	    }
	    if (Gtk::Main::level() == 1) {
		printf("\nquit (%s)\n", signame);
		Glib::signal_idle().connect_once(sigc::mem_fun(*this, &PosixSignals::quit_slot));
	    } else {
		gx_system::GxExit::get_instance().exit_program(
		    (boost::format("\nQUIT (%1%)\n") % signame).str());
	    }
	    break;
	default:
	    assert(false);
        }
    }
}


/****************************************************************
 ** main()
 */

/* --------- Guitarix main ---------- */
int main(int argc, char *argv[]) {
#ifdef DISABLE_NLS
// break
#elif IS_MACOSX
// break
#elif ENABLE_NLS
    bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
    bind_textdomain_codeset(GETTEXT_PACKAGE, "UTF-8");
    textdomain(GETTEXT_PACKAGE);
#endif

    try {
	// ----------------------- init basic subsystems ----------------------
	Glib::thread_init();
	Glib::init();
	Gxw::init();

	gx_system::CmdlineOptions options;
	Gtk::Main main(argc, argv, options);
	options.process(argc, argv);
	PosixSignals posixsig; // catch unix signals in special thread
	gx_engine::GxEngine engine(options.get_plugin_dir(), gx_gui::get_group_table());

	// ------ initialize parameter list ------
	gx_engine::audio.register_parameter();
	gx_engine::midi.register_parameter();
	gx_gui::guivar.register_gui_parameter();

	gx_gui::parameter_map.set_init_values();

	// ---------------- Check for working user directory  -------------
	gx_preset::GxSettings::check_settings_dir(options);

	// ------ time measurement (debug) ------
#ifndef NDEBUG
	gx_system::add_time_measurement();
#endif

	// ----------------------- init GTK interface----------------------
	g_type_class_unref(g_type_class_ref(GTK_TYPE_IMAGE_MENU_ITEM)); //FIXME...
	g_object_set(gtk_settings_get_default(), "gtk-menu-images", TRUE, NULL);

	gx_gui::GxMainInterface gui(engine, options);
	gui.setup();
	gx_jconv::gx_load_jcgui();
	// ---------------------- initialize jack gxjack.client ------------------
	if (gui.jack.gx_jack_init()) {
	    // -------- initialize gx_head engine --------------------------
	    gui.gx_settings.load(gx_system::GxSettingsBase::state);
	    gx_preset::gxpreset.gx_refresh_preset_menus();
	    gx_engine::gx_engine_init();

	    // -------- set jack callbacks and activation -------------------
	    gui.jack.gx_jack_callbacks();
	    engine.set_state(gx_engine::kEngineOn);

	    // -------- init port connections
	    gui.jack.gx_jack_init_port_connection();
	} else {
	    gui.gx_settings.load(gx_system::GxSettingsBase::state);
	    gx_preset::gxpreset.gx_refresh_preset_menus();
	    gx_engine::gx_engine_init();
	}

	/*-- set rc file overwrite it with export--*/
	if (!options.get_rcset().empty()) {
	    gx_gui::gx_actualize_skin_index(options.skin, options.get_rcset());
	}

	// ----------------------- run GTK main loop ----------------------
	engine.check_module_lists();
	gx_ui::GxUI::updateAllGuis(true);
	gui.show();
	engine.clear_stateflag(gx_engine::ModuleSequencer::SF_INITIALIZING);
	gui.run();
	// ------------- shut things down
	//gx_system::gx_clean_exit(NULL, NULL);
    } catch (const Glib::OptionError &e) {
	cerr << e.what() << endl;
	cerr << _("use \"guitarix -h\" to get a help text") << endl;
	return 1;
    } catch (const gx_system::GxFatalError &e) {
	cerr << e.what() << endl;
	return 1;
    }
    return 0;
}

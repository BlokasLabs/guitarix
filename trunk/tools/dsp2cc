#! /usr/bin/python
# -*- coding: utf-8 -*-

import re, os, sys, StringIO
from subprocess import Popen, PIPE
from optparse import OptionParser


num_re = r"(-?\d*\.?\d*e?[+-]?\d*f?)"

class UIDefs(object):

    class UID(dict):
        def write(self, fp, v, prefix):
            self["tail"] = "".join([", "+x for x in self["value"]])
            self["prefix"] = prefix
            if self.has_key("alias"):
                assert not self.has_key("enum")
                fp.write('#undef %(variable)s\n' % self)
                fp.write('\t%(variable)s_ = %(prefix)sregisterVar("%(id)s","%(name)s","%(type)sA","%(tooltip)s",&%(variable)s%(tail)s);\n' % self)
            elif self.has_key("enum"):
                def value_pair(s):
                    m = re.match(r"(.*)\[(.*)\]$", s)
                    if m:
                        return '{"%s",N_("%s")}' % (m.group(1), m.group(2))
                    else:
                        return '{"%s"}' % s
                enumvals = ",".join([value_pair(x) for x in self["enum"].split("|")]+["{0}"])
                self["ename"] = ename = self["variable"] + "_values"
                fp.write('\tstatic const value_pair %s[] = {%s};\n' % (ename, enumvals))
                fp.write('\t%(prefix)sregisterEnumVar("%(id)s","%(name)s","%(type)s","%(tooltip)s",%(ename)s,&%(variable)s%(tail)s);\n' % self)
            else:
                fp.write('\t%(prefix)sregisterVar("%(id)s","%(name)s","%(type)s","%(tooltip)s",&%(variable)s%(tail)s);\n' % self)

        def __getitem__(self, n):
            try:
                return dict.__getitem__(self, n)
            except KeyError:
                return ""

    def __init__(self):
        self.ui = {}

    def add(self, element, key, value):
        try:
            uid = self.ui[element]
        except KeyError:
            self.ui[element] = uid = self.UID(variable=element)
        uid[key] = value

    def get(self, element, key):
        return self.ui[element][key]

    def has(self, element, key):
        return self.ui[element].has_key(key)

    def var_filter(self, const=2):
        s = "|".join([r"%s\s*=\s*%s" % (v, num_re) for v in self.ui.keys()])
        def filt(t):
            if re.compile(r"\s*("+s+");").match(t):
                return True
            if const == 1 and t.startswith("for "):
                return True
            if const == 0 and not t.startswith("for "):
                return True
            return False
        return filt

    def write(self, fp, prefix=""):
        for v, r in self.ui.items():
            r.write(fp, v, prefix)

    def check_parameter(self, fname, uiname, l):
        s1 = set(l)
        s2 = set([v["id"] for v in self.ui.values()])
        d = s2 - s1
        errlevel = 0
        if d:
            print ("%s:warning: parameters in faust dsp not used in %s: %s"
                   % (fname, uiname, ", ".join(d)))
            errlevel = 1
        d = s1 - s2
        if d:
            print ("%s:error: parameters in %s not found in faust dsp: %s"
                   % (fname, uiname, ", ".join(d)))
            errlevel = 2
        return errlevel


class Parser(object):

    def skip_until(self, exp):
        r = re.compile(exp)
        for line in self.lines:
            m = r.match(line)
            if m:
                return m
        return None

    def skip_while(self, exp):
        m = re.compile(exp).match
        for line in self.lines:
            if not m(line):
                return line
        return ""

    def copy(self, exp, line=None):
        cp = []
        if line:
            cp.append(line)
        m = re.compile(exp).match
        for line in self.lines:
            if m(line):
                break
            cp.append(line)
        # remove indentation
        m = re.compile(r"\t*").match
        n = 10
        for l in cp:
            if l != "\n":
                n = min(n, len(m(l).group(0)))
        return [l[n:] for l in cp]

    def get_section_list(self):
        return "includes", "var-decl", "var-init", "var-free", "ui", "compute"

    def getIO(self, s):
        e = r"\s*virtual int getNum%sputs\(\)\s*{\s*return\s*(\d+);\s*}" % s
        for line in self.lines:
            m = re.match(e, line)
            if m:
                return int(m.group(1))
        raise ValueError("getNum%sputs not found in source" % s)

    def parse_name(self, s):
        def findBrackets(aString):
            l = []
            n = []
            while aString:
                v = aString.split('[',1)
                if len(v) == 2:
                    s, match = v
                else:
                    n.append(aString)
                    break
                s.strip()
                if s:
                    n.append(s)
                match.lstrip()
                open = 1
                for index in range(len(match)):
                    if match[index] in '[]':
                        open = (open + 1) if match[index] == '[' else (open - 1)
                    if not open:
                        l.append(match[:index])
                        break
                aString = match[index+1:].lstrip()
            return " ".join(n), l
        s, l = findBrackets(s)
        for v in l:
            if ":" in v:
                key, value = v.split(":",1)
            else:
                key = v
                value = ""
            if key == "name" and value:
                self.groups[s] = value
        return s

    def readUI(self, exp):
        stop = re.compile(exp).match
        pre = r"\s*interface->"
        nm = '"([^"]*)"'
        vr = "([a-zA-Z_][0-9a-zA-Z_]*)"
        sarg = (r"%s,\s*&%s,\s*%s,\s*%s,\s*%s,\s*%s"
                % (nm, vr, num_re, num_re, num_re, num_re))
        openbox = re.compile(pre+r"open(Horizontal|Vertical)Box\(%s\);" % nm).match
        closebox = re.compile(pre+r"closeBox\(\);").match
        vslider = re.compile(pre+r"addVerticalSlider\(%s\);" % sarg).match
        hslider = re.compile(pre+r"addHorizontalSlider\(%s\);" % sarg).match
        numentry = re.compile(pre+r"addNumEntry\(%s\);" % sarg).match
        checkbutton = re.compile(pre+r"addCheckButton\(%s,\s*&%s\);" % (nm, vr)).match
        declare = re.compile(pre+r"declare\((?:&%s|0),\s*%s,\s*%s\);" % (vr, nm, nm)).match
        stack = []
        def make_name_int(mystack):
            st = mystack[1:]
            if not st:
                return mystack[0]
            s = make_name_int(st)
            if s.startswith("."):
                return s
            return mystack[0] + "." + s
            
        def make_name(nm):
            stack.append(nm)
            nm = make_name_int(stack)
            stack.pop()
            if nm.startswith("."):
                return nm[1:]
            return nm

        nextbox = {}
        for line in self.lines:
            if stop(line):
                return
            m = openbox(line)
            if m:
                grp = m.group(2)
                if "[" in grp:
                    # 0.9.30 didn't parse [..] in [hv]group names
                    grp = self.parse_name(grp)
                if nextbox:
                    if "name" in nextbox:
                        self.groups[grp] = nextbox["name"]
                    # ignore all other attributes for now
                    nextbox = {}
                if not stack:
                    if self.toplevel and grp == self.modname:
                        grp = self.toplevel
                    if not self.topname:
                        self.topname = grp
                stack.append(grp)
                continue
            if closebox(line):
                stack.pop()
                continue
            m = vslider(line) or hslider(line) or numentry(line)
            if m:
                vn = m.group(2)
                self.ui.add(vn, "type", "S")
                self.ui.add(vn, "id", make_name(m.group(1)))
                self.ui.add(vn, "value", m.groups()[2:])
                continue
            m = checkbutton(line)
            if m:
                vn = m.group(2)
                self.ui.add(vn, "type", "B")
                self.ui.add(vn, "id", make_name(m.group(1)))
                self.ui.add(vn, "value", ("0.0","0.0","1.0","1.0"))
                continue
            m = declare(line)
            if m:
                if m.group(1) is None: # 0.9.43: attributes for next openbox
                    nextbox[m.group(2)] = m.group(3)
                else:
                    self.ui.add(m.group(1), m.group(2), m.group(3))
                continue
            assert False, line

    def readMeta(self):
        "only needed for faust 9.4; not used at the moment"
        self.meta = {}
        stop = re.compile(r'// Code generated with Faust').match
        declare = re.compile(r'// ([^:]+):\s*"([^"]*)"\s*$').match
        for line in self.lines:
            if stop(line):
                return
            m = declare(line)
            if m:
                key = m.group(1)
                value = m.group(2)
                self.meta[key] = value
                if key == "name":
                    self.toplevel = value

    def splitgroups(self, value):
        d = {}
        for l in re.split(r"\]\s*,\s*", value):
            a = re.split(r"\s*\[\s*",l,1)
            g = a[0].strip()
            if len(a) == 1:
                v = "?"
            else:
                v = a[1].rstrip(" ]")
            d[g] = v
        return d
            

    def readMeta2(self, stop_expr):
        self.meta = {}
        stop = re.compile(stop_expr).match
        declare = re.compile(r'\s*m->declare\s*\("([^"]+)"\s*,\s*"([^"]*)"\);').match
        for line in self.lines:
            if stop(line):
                return
            m = declare(line)
            if m:
                key = m.group(1)
                value = m.group(2)
                self.meta[key] = value
                if key == "id":
                    self.toplevel = value
                elif key == "name":
                    self.name = value
                elif key == "groups":
                    self.groups.update(self.splitgroups(value));

    def readIncludes(self, stop_expr):
        stop = re.compile(stop_expr).match
        cp = []
        for line in self.lines:
            if stop(line):
                return cp
            if line.startswith('#include "'):
                cp.append(line)
        raise RuntimeError("EOF while looking for #include")

    def change_var_decl(self, lines):
        param_matcher = re.compile(r"FAUSTFLOAT\s+([a-zA-Z_0-9]+);\n$").match
        array_matcher = re.compile(r"(int|float|double)\s+([a-zA-Z_0-9]+)\s*\[\s*(\d+)\s*\]\s*;\n$").match
        out = []
        for l in lines:
            m = param_matcher(l);
            if m:
                var = m.group(1)
                alias = self.ui.has(var,"alias")
                if alias:
                    #l = ('FAUSTFLOAT&\t%s = get_alias("%s");\n'
                    #     % (var, self.ui.get(var, "id")))
                    out.append(l)
                    out.append('FAUSTFLOAT\t*%s_;\n' % var)
                    l = '#define %s (*%s_)\n' % (var, var)
            if self.memory_threshold:
                m = array_matcher(l)
                if m:
                    sz = {"int": 4, "float": 4, "double": 8}[m.group(1)]
                    alen = int(m.group(3))
                    if alen * sz > self.memory_threshold:
                        l = "%s *%s;\n" % (m.group(1), m.group(2))
                        self.memlist.append((m.group(2), m.group(1), alen))
            if l.startswith(("int","float","double","FAUSTFLOAT")):
                l = "static " + l
            out.append(l)
        return out

    def add_var_alloc(self):
        l = []
        for v, t, s in self.memlist:
            l.append("if (!%s) %s = new %s[%d];\n" % (v, v, t, s))
        return l

    def add_var_free(self):
        l = []
        for v, t, s in self.memlist:
            l.append("if (%s) { delete %s; %s = 0; }\n" % (v, v, v))
        return l

    def __init__(self, lines, modname, memory_threshold):
        self.lines = lines
        self.modname = modname
        self.memory_threshold = memory_threshold;
        self.toplevel = None
        self.topname = None
        self.name = None
        self.groups = {}
        self.memlist = []
        s = {}
        self.ui = UIDefs()
        #self.readMeta()  # (needed only for faust 9.4
        self.headvers = self.skip_until(r"\s*//\s*(Code generated with Faust.*)").group(1)
        s["includes"] = self.readIncludes(r"  private:")
        #self.skip_until(r"  private:")
        var_decl = self.copy(r"  public:")
        self.skip_until(r"^\s*static\s+void\s+metadata\s*\(\s*Meta\s*\*\s*m\s*\)\s*{")
        self.readMeta2(r"\s*}\s*\n$")
        self.numInputs = self.getIO("In")
        self.numOutputs = self.getIO("Out")
        self.skip_until(r"\s*static void classInit")
        s["var-init"] = self.copy(r"\s*}$")
        self.skip_until(r"\s*virtual void instanceInit")
        s["var-init"] += self.copy(r"\s*}$")
        self.skip_until(r"\s*virtual void buildUserInterface")
        s["ui"] = self.readUI(r"\s*}$")
        s["var-decl"] = self.change_var_decl(var_decl)
        s["var-init"] = s["var-init"]
        s["var-alloc"] = self.add_var_alloc()
        s["var-free"] = self.add_var_free()
        self.skip_until(r"\s*virtual void compute")
        iodef = r"\s*(float|FAUSTFLOAT)\s*\*\s*(in|out)put(\d+)\s*=\s*\2put\[\3\];"
        s["compute"] = self.copy(iodef)
        line = self.skip_while(iodef)
        s["compute"] += self.copy("\s*}$", line)
        self.sections = s
        if self.topname is None:
            self.topname = self.modname
        # ignore any following definitions of static class members
        #self.checkfor(r".*\bexp\b", "compute")

    def checkfor(self, re_exp, sect):
        loop = re.compile(r"\s*for\s*\(int\s+i=0;\s*i<count;\s*i\+\+\)\s*{").match
        re_m = re.compile(re_exp).match
        in_loop = False
        for l in self.sections[sect]:
            if not in_loop:
                if loop(l):
                    in_loop = True
                continue
            if re_m(l):
                print self.modname, l

    def getNumInputs(self):
        return self.numInputs

    def getNumOutputs(self):
        return self.numOutputs

    def __getitem__(self, n):
        return self.sections[n]

    def formatted_groups(self, plugin_id):
        l = []
        for k, v in self.groups.items():
            if k == plugin_id:
                continue
            k = '"'+k+'"'
            if v:
                v = 'N_("%s")' % v
            else:
                v = '""'
            l.append("\t%s, %s,\n" % (k, v))
        return "".join(l) + "\t0\n"
  
    def write(self, fp, sect, indent=0, filt=lambda l: False):
        pre = "\t" * indent
        for l in self.sections[sect]:
            if filt(l):
                continue
            fp.write(pre)
            fp.write(l)

activate = """
static int activate(bool start, PluginDef* = 0)
{
    if (start) {
        if (!mem_allocated) {
            mem_alloc();
            clear_state();
        }
    } else if (!mem_allocated) {
        mem_free();
    }
    return 0;
}

"""

plugin = r"""
PluginDef plugin = {
    PLUGINDEF_VERSION,
    0,   // flags
    "%s",  // id
    %s,  // name
    %s,  // groups
    %s,  // mono_audio
    %s,  // stereo_audio
    init,  // set_samplerate
    %s,  // activate plugin
    register_params,
    %s,   // load_ui
    %s,  // clear_state
};
"""

plugin_standalone_header = """
#include "gx_faust_support.h"
#include "gx_plugin.h"
#define N_(x) (x)

"""

plugin_standalone_footer = """
extern "C" __attribute__ ((visibility ("default"))) int
get_gx_plugins(int *count, PluginDef **pplugin)
{
    *count = 1;
    *pplugin = &plugin;
    return 0;
}
"""

loadui_glade = r"""
static const char *glade_def = "\
%s";

static int load_ui(const UiBuilder& b) {
    b.load_glade(glade_def);
    return 0;
}
"""

def output(fp, p, fname, options):
    has_activate = len(p.memlist) > 0
    fp.write("// generated from file '%s' by dsp2cc:\n" % fname)
    fp.write("// %s\n\n" % p.headvers)
    if options.init_type == "plugin" and options.template_type in ("staticlib", "sharedlib"):
        fp.write(plugin_standalone_header)
    p.write(fp, "includes")
    if options.in_namespace:
        fp.write("namespace %s {\n" % options.in_namespace)
    fp.write("namespace %s {\n" % p.modname)
    p.write(fp, "var-decl")
    if has_activate:
        fp.write("static bool mem_allocated = false;\n")
    fp.write("static int\tfSamplingFreq;\n\n")
    s = StringIO.StringIO()
    p.write(s, "var-init", 1, filt=p.ui.var_filter(0))
    state = s.getvalue()
    if state:
        fp.write("static void clear_state(PluginDef* = 0)\n{\n")
        fp.write(state);
        fp.write("}\n\n")
    if state and not has_activate:
        fp.write("static void init(unsigned int samplingFreq, PluginDef* = 0)\n{\n")
        p.write(fp, "var-init", 1, filt=p.ui.var_filter(1))
        fp.write('\tclear_state();\n')
        fp.write("}\n\n")
    else:
        fp.write("static void init(unsigned int samplingFreq, PluginDef* = 0)\n{\n")
        p.write(fp, "var-init", 1, filt=p.ui.var_filter(1))
        fp.write("}\n\n")
    if has_activate:
        fp.write("static void mem_alloc()\n{\n")
        p.write(fp, "var-alloc", 1)
        fp.write("\tmem_allocated = true;\n}\n\n")
        fp.write("static void mem_free()\n{\n")
        fp.write("\tmem_allocated = false;\n")
        p.write(fp, "var-free", 1)
        fp.write("}\n\n")
        fp.write(activate)
    fp.write("%s(int count%s%s" % (
        "static void compute" if options.init_type == "plugin" else "void compute",
        "".join([", float *input%d" % i for i in range(p.getNumInputs())]),
        "".join([", float *output%d" % i for i in range(p.getNumOutputs())])))
    if options.init_type == "plugin":
        fp.write(", PluginDef *)\n{\n")
    else:
        fp.write(")\n{\n")
    p.write(fp, "compute", 1)
    fp.write("\t}\n}\n\n")
    if options.init_type == "ctor":
        fp.write("static struct RegisterParams { RegisterParams(); } RegisterParams;\n")
        fp.write("RegisterParams::RegisterParams()\n{\n")
        p.ui.write(fp)
        fp.write('\tregisterInit("%s", init);\n' % p.topname)
        fp.write("}\n")
    elif options.init_type == "plugin":
        fp.write("static int register_params(const ParamReg& reg)\n{\n")
        p.ui.write(fp, prefix="reg.")
        fp.write("\treturn 0;\n}\n")
        load_ui = "0"
        ui_name = fname.replace(".dsp", "_ui.glade")
        if os.path.exists(ui_name):
            xml = file(ui_name).read()
            if p.ui.check_parameter(
                fname, ui_name,
                re.findall('<property name="var_id">([^<]*)</property>',xml)):
                raise SystemExit, 1
            fp.write(loadui_glade % xml.replace("\\",r"\\").replace("\n","\\n\\\n").replace('"',r'\"'))
            load_ui = "load_ui"
        else:
            ui_name = fname.replace(".dsp", "_ui.cc")
            if os.path.exists(ui_name):
                ccdef = file(ui_name).read()
                if p.ui.check_parameter(
                    fname, ui_name,
                    re.findall(r'\.create_[a-zA-Z0-9_]+\("([^"]*)',ccdef)):
                    raise SystemExit, 1
                fp.write("\n")
                fp.write(ccdef)
                load_ui = "load_ui"
        plugin_id = p.toplevel or p.topname
        if p.groups:
            fp.write("\nstatic const char* groups[] = {\n%s\t};\n" % p.formatted_groups(plugin_id))
        if p.name:
            plugin_name = 'N_("%s")' % p.name
        else:
            plugin_name = '"?%s"' % p.modname
        fp.write(plugin % (
            plugin_id,    # id
            plugin_name,  # name
            "groups" if p.groups else "0",  # groups
            "compute" if p.getNumOutputs() == 1 else "0",  # mono_audio
            "compute" if p.getNumOutputs() == 2 else "0",  # stereo_audio
            "activate" if has_activate else "0",  # activate plugin
            load_ui, # load_ui
            "clear_state" if state else "0", # clear_state
            ))
    else:
        fp.write("static int register_params(const ParamReg& reg)\n{\n")
        p.ui.write(fp, prefix="reg.")
        fp.write("\treturn 0;\n}\n")
    if options.init_type == "plugin" and options.template_type == "sharedlib":
        fp.write(plugin_standalone_footer)
    fp.write("\n} // end namespace %s\n" % p.modname)
    if options.in_namespace:
        fp.write("} // end namespace %s\n" % options.in_namespace)

def main():
    op = OptionParser(usage="usage: %prog [options] <faust-dsp-file>")
    op.add_option("-o", "--output", dest="oname",
                  help="write c++ code to FILE", metavar="FILE")
    op.add_option("-d", "--double", dest="faust", action="append",
                  help="additional faust options, build with double precision") 
    op.add_option("-f", "--float", dest="faustf", action="append",
                  help="additional faust options, build with single precision")
    op.add_option("-s", "--memory-threshold", dest="memory_threshold",
                  default=0, type="int",
                  help="change static memory allocations above threshold to dynamic ones")
    init_opts = ["ctor", "no-init", "plugin", "plugin-standalone"]
    op.add_option("-i", "--init-type", dest="init_type", action="store", default="ctor",
                  help="type of init code generation: %s" % ", ".join(init_opts))
    template_opts = ["embed", "staticlib", "sharedlib"]
    op.add_option("-t", "--template-type", dest="template_type", action="store",
                  default="embed",
                  help="template for code generation: %s" % ", ".join(template_opts))
    op.add_option("-N", "--in-namespace", action="store",
                  help="put definitions inside an extra namespace")
    options, args = op.parse_args()
    if options.init_type not in init_opts:
        op.error("unknown init-type")
    if options.template_type not in template_opts:
        op.error("unknown template-type")
    if len(args) != 1:
        op.error("exactly one input filename expected\n")
    fname = args[0]
    if not os.path.exists(fname):
        print "error: can't open '%s'" % fname
        raise SystemExit, 1
    if options.faust:
        precision = ' -double'
    elif options.faustf:
        precision = ' -single'
    else:
        precision = ''
    faust = Popen("faust %s%s" % (fname, precision), shell=True, stdout=PIPE)
    try:
        parser = Parser(faust.stdout,
                        os.path.splitext(os.path.basename(fname))[0],
                        options.memory_threshold)
    except ValueError, e:
        if faust.wait() == 0:
            print e
        raise SystemExit, 1
    if options.oname:
        outp = file(options.oname,"w")
    else:
        outp = sys.stdout
    output(outp, parser, fname, options)

if __name__ == "__main__":
    main()

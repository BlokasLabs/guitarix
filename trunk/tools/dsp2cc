#! /usr/bin/python
# -*- coding: utf-8 -*-

import re, os, sys
from subprocess import Popen, PIPE
from optparse import OptionParser


num_re = r"(-?\d*\.?\d*e?-?\d*f)"

class UIDefs(object):

    class UID(dict):
        def write(self, fp, v):
            self["tail"] = "".join([", "+x for x in self["value"]])
            fp.write('\tregisterVar("%(id)s","%(name)s","%(type)s","%(tooltip)s",&%(variable)s%(tail)s);\n' % self)

        def __getitem__(self, n):
            try:
                return dict.__getitem__(self, n)
            except KeyError:
                return ""

    def __init__(self):
        self.ui = {}

    def add(self, element, key, value):
        try:
            uid = self.ui[element]
        except KeyError:
            self.ui[element] = uid = self.UID(variable=element)
        uid[key] = value

    def get(self, element, key):
        return self.ui[element][key]

    def var_filter(self):
        s = "|".join([r"%s\s*=\s*%s" % (v, num_re) for v in self.ui.keys()])
        return re.compile(r"\s*("+s+");").match

    def write(self, fp):
        for v, r in self.ui.items():
            r.write(fp, v)

class Parser(object):

    def skip_until(self, exp):
        r = re.compile(exp)
        for line in self.lines:
            m = r.match(line)
            if m:
                return m
        return None

    def skip_while(self, exp):
        m = re.compile(exp).match
        for line in self.lines:
            if not m(line):
                return line
        return ""

    def copy(self, exp, line=None):
        cp = []
        if line:
            cp.append(line)
        m = re.compile(exp).match
        for line in self.lines:
            if m(line):
                break
            cp.append(line)
        # remove indentation
        m = re.compile("\t*").match
        n = 10
        for l in cp:
            if l != "\n":
                n = min(n, len(m(l).group(0)))
        return [l[n:] for l in cp]

    def get_section_list(self):
        return "var-decl", "var-init", "ui", "compute"

    def getIO(self, s):
        e = r"\s*virtual int getNum%sputs\(\)\s*{\s*return\s*(\d+);\s*}" % s
        for line in self.lines:
            m = re.match(e, line)
            if m:
                return int(m.group(1))
        raise ValueError("getNum%sputs not found in source" % s)

    def readUI(self, exp):
        stop = re.compile(exp).match
        pre = r"\s*interface->"
        nm = '"([^"]*)"'
        vr = "([a-zA-Z_][0-9a-zA-Z_]*)"
        sarg = ("%s,\s*&%s,\s*%s,\s*%s,\s*%s,\s*%s"
                % (nm, vr, num_re, num_re, num_re, num_re))
        openbox = re.compile(pre+r"open(Horizontal|Vertical)Box\(%s\);" % nm).match
        closebox = re.compile(pre+r"closeBox\(\);").match
        vslider = re.compile(pre+r"addVerticalSlider\(%s\);" % sarg).match
        hslider = re.compile(pre+r"addHorizontalSlider\(%s\);" % sarg).match
        numentry = re.compile(pre+r"addNumEntry\(%s\);" % sarg).match
        checkbutton = re.compile(pre+r"addCheckButton\(%s,\s*&%s\);" % (nm, vr)).match
        declare = re.compile(pre+r"declare\(&%s,\s*%s,\s*%s\);" % (vr, nm, nm)).match
        stack = []
        def make_name(nm):
            if nm.startswith("."):
                nm = nm[1:]
            else:
                stack.append(nm)
                nm = ".".join(stack)
                stack.pop()
            return nm

        for line in self.lines:
            if stop(line):
                return
            m = openbox(line)
            if m:
                grp = m.group(2)
                if not stack:
                    if self.toplevel and grp == self.modname:
                        grp = self.toplevel
                stack.append(grp)
                continue
            if closebox(line):
                stack.pop()
                continue
            m = vslider(line) or hslider(line) or numentry(line)
            if m:
                vn = m.group(2)
                self.ui.add(vn, "type", "S")
                self.ui.add(vn, "id", make_name(m.group(1)))
                self.ui.add(vn, "value", m.groups()[2:])
                continue
            m = checkbutton(line)
            if m:
                vn = m.group(2)
                self.ui.add(vn, "type", "S")
                self.ui.add(vn, "id", make_name(m.group(1)))
                self.ui.add(vn, "value", m.groups()[2:])
                continue
            m = declare(line)
            if m:
                self.ui.add(m.group(1), m.group(2), m.group(3))
                continue
            
            assert False, line

    def readMeta(self):
        "only needed for faust 9.4; not used at the moment"
        self.meta = {}
        stop = re.compile(r'// Code generated with Faust').match
        declare = re.compile(r'// ([^:]+):\s*"([^"]*)"\s*$').match
        for line in self.lines:
            if stop(line):
                return
            m = declare(line)
            if m:
                key = m.group(1)
                value = m.group(2)
                self.meta[key] = value
                if key == "name":
                    self.toplevel = value

    def readMeta2(self, stop_expr):
        self.meta = {}
        stop = re.compile(stop_expr).match
        declare = re.compile(r'\s*m->declare\s*\("([^"]+)"\s*,\s*"([^"]*)"\);').match
        for line in self.lines:
            if stop(line):
                return
            m = declare(line)
            if m:
                key = m.group(1)
                value = m.group(2)
                self.meta[key] = value
                if key == "name":
                    self.toplevel = value

    def debug_change_var_decl(self, lines):
        matcher = re.compile("FAUSTFLOAT\s+([a-zA-Z_0-9]+);\n$").match
        out = []
        for l in lines:
            m = matcher(l);
            if m:
                var = m.group(1)
                oldvar = self.ui.get(var,"old")
                if not oldvar:
                    raise ValueError, "error: no oldvar for " + self.ui.get(var,"id")
                l = ("FAUSTFLOAT&\t%s=*(float*)&GxEngine::instance()->%s;\n"
                     % (var, oldvar))
            out.append(l)
        return out

    def __init__(self, lines, modname):
        self.modname = modname
        self.toplevel = None
        self.lines = lines
        s = {}
        self.ui = UIDefs()
        #self.readMeta()  # (needed only for faust 9.4
        self.skip_until(r"  private:")
        var_decl = self.copy(r"  public:")
        self.skip_until(r"^\s*static\s+void\s+metadata\s*\(\s*Meta\s*\*\s*m\s*\)\s*{")
        self.readMeta2(r"\s*}\s*\n$")
        self.numInputs = self.getIO("In")
        self.numOutputs = self.getIO("Out")
        self.skip_until(r"\s*virtual void instanceInit")
        s["var-init"] = self.copy(r"\s*}$")
        self.skip_until(r"\s*virtual void buildUserInterface")
        s["ui"] = self.readUI(r"\s*}$")
        s["var-decl"] = self.debug_change_var_decl(var_decl)
        self.skip_until(r"\s*virtual void compute")
        iodef = r"\s*(float|FAUSTFLOAT)\s*\*\s*(in|out)put(\d+)\s*=\s*\2put\[\3\];"
        s["compute"] = self.copy(iodef)
        line = self.skip_while(iodef)
        s["compute"] += self.copy("\s*}$", line)
        self.sections = s

    def getNumInputs(self):
        return self.numInputs

    def getNumOutputs(self):
        return self.numOutputs

    def __getitem__(self, n):
        return self.sections[n]

    def write(self, fp, sect, indent=0, filt=lambda l: False):
        pre = "\t" * indent
        for l in self.sections[sect]:
            if filt(l):
                continue
            fp.write(pre)
            fp.write(l)

def output(fp, p, fname):
    fp.write("namespace %s {\n" % p.modname)
    fp.write("// generated from file '%s'\n\n" % fname)
    p.write(fp, "var-decl")
    fp.write("int\tfSamplingFreq;\n\n")
    fp.write("void init(int samplingFreq)\n{\n")
    p.write(fp, "var-init", 1, filt=p.ui.var_filter())
    fp.write("}\n\n")
    fp.write("void compute(int count, %s, %s)\n{\n" % (
        ", ".join(["float *input%d" % i for i in range(p.getNumInputs())]),
        ", ".join(["float *output%d" % i for i in range(p.getNumOutputs())])))
    p.write(fp, "compute", 1)
    fp.write("\t}\n}\n\n")
    fp.write("static struct RegisterParams { RegisterParams(); } RegisterParams;\n")
    fp.write("RegisterParams::RegisterParams()\n{\n")
    p.ui.write(fp)
    fp.write('\tregisterInit(init);\n')
    fp.write("}\n")
    fp.write("\n} // end namespace %s\n" % p.modname)

def main():
    op = OptionParser(usage="usage: %prog [options] <faust-dsp-file>")
    op.add_option("-o", "--output", dest="oname",
                  help="write c++ code to FILE", metavar="FILE")
    options, args = op.parse_args()
    if len(args) != 1:
        op.error("exactly one input filename expected\n")
    fname = args[0]
    if not os.path.exists(fname):
        print "error: can't open '%s'" % fname
        raise SystemExit, 1
    faust = Popen("faust %s" % fname, shell=True, stdout=PIPE)
    try:
        parser = Parser(faust.stdout, os.path.splitext(os.path.basename(fname))[0])
    except ValueError, e:
        if faust.wait() == 0:
            print e
        raise SystemExit, 1
    if options.oname:
        outp = file(options.oname,"w")
    else:
        outp = sys.stdout
    output(outp, parser, fname)

if __name__ == "__main__":
    main()
